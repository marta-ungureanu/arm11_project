\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage[a4paper, total={6.5in, 10in}]{geometry}
\usepackage[parfill]{parskip}
\begin{document}

\title{ARM11 Final Report}
\author{Group 3: Andrew Pearcy, Marta Ungureanu, Maurizio Zen, Oana Ciocioman}

\maketitle

\section{Assembler}
\subsection{Structure}
Our assembler carries out the following process. First the file to read from is opened, if this fails an error is printed. If this succeeds, then we find the size of the file and allocate a table of the labels on the heap with a size relative to that of the file input. We also allocate a table for printing out values that are too large to be stored in the offset of an instruction. These will be printed at the end of the instructions. Next our assembler begins reading the file input line by line.  Each line is saved into an array of strings for later use. Each line is taken and if it contains a colon, then that line is a label and that label will be added to our table. In the case where the instruction is not a label we pass the instruction to our decode function which compares the first word of the instruction with a table of operations. This table maps instructions to unique opcodes and instruction types. The instruction type determines which one of: Data Processing, Multiply, Single Data Transfer and Branch is to be encoded. Decode then calls the appropriate function and passes the instruction along with additional parameters depending on which type of instruction is being executed. \par
\subsection{Branch instruction}
For example, branch also requires the current address of the instruction to be passed in order to calculate the offset between the label and the current address of the instruction. This ensures that the program counter jumps to the appropriate location, taking into account the off-by-eight bytes-effect caused by the pipeline. If the offset is negative, then the function takes into account that the offset needs to be shifted preserving the two's complement form. Branch also reads the type of branch instruction in order to determine what the condition field of the instruction should be. These two values are then composed and written to our binary output file.\par
\subsection{Multiply instruction}
With multiply we pass the remaining part of the instruction along with the mnemonic. The function then determines the destination register and tests the mnemonic to determine if the instruction is a multiply or accumulator. If it is an accumulator it sets the accumulator bit and then tokenises and converts the three registers into binary values. Otherwise it is a normal multiply which only takes two other registers to multiply together. These two values are then composed and written to our binary output file. \par
\subsection{Data Processing instruction}
The Data Processing function takes the remaining part of the instruction and the opcode which is determined from our instructions table. The function then tests the opcode to decide which type of instruction is to be executed. LSL is a special instruction so it is tested for first with a unique opcode of 16 which is unattainable by the 4 bit opcode field. If the instruction is an LSL a move instruction is carried out with the appropriate parameters. \par
If the instruction to be executed requires the result to be written to a register then it enters the second case which determines the destination and source registers and if there are additional arguments, for example in the case of a shifted register being operand2 then these are read into argument 1 and 2. After these have been read in the function determines if operand2 is an immediate operand or a shifted register by checking the first part of the instruction, looking for a \# or a 0x to signify an immediate value. If this is the case then another function (encodeImmediateOperand) determines whether or not the value can be represented as an eight bit value and a shift. If it can it is encoded using the function encodeImmediateRotation, if not an error is thrown. Alternatively, if operand2 is not an immediate value then the registers and the arguments which were tokenised earlier are sent to encodeShiftedRegister which returns a binary representation of the instruction. \par
A similar process is carried out for the operations which do not require saving the values into registers. The final case is a move instruction which only take a destination register and then encodes operand2 using the same process as the other opcodes. Finally, the instruction is written to our output file.
\subsection{Single Data Transfer instruction}
Finally, the Single Data Processing instruction takes the remaining part of the instruction as well as the type (load or store) and the address of the current instruction. Firstly, it determines the destination/source register depending on whether we are loading or storing and sets the UIP flags. Now, it determines whether the instruction is load or store and sets the L flag of our binary instruction appropriately. Leading whitespace is removed and one of four cases is entered. The first case is when we have an immediate value to be loaded. If the value is less than 255 then the instruction can be written as a move instruction. Otherwise it will be saved in our finalPrint table which is printed at the end of the instructions. To encode the instruction we take the base register to be the PC and then we compute the offset by taking into account the number of instructions, number of values to be printed, the size of an instruction and the PC. \par
The second case is when the rest of the instruction is a single register which is pre-indexed. In this case we simply encode the base register as the supplied register. The third case is when we have a pre-indexed instruction and the fourth case is when we have a post-indexed instruction. In both cases the offset is calculated using a helper function getOffset. getOffset first determines if we have a shift, which is optional, if it does then it encodes the shift using the encodeShiftedRegister method from data processing. Alternatively, the offset will be an immediate value, in which case a second helper function convertToNumber which takes the string and returns the integer value. The final case in getOffset is when the offset is represented by a register. In this case we set the shift flag to 1 for the binary instruction. In both the immediate value case and the shift register case the sign of the shift is taken into account and the U flag is set accordingly, 1 for plus and 0 for minus.

\section{General Purpose Input/Output on a RaspberryPi}
The third part of our project involved using our assembler to encode assembly which we had written ourselves. We were meant to write an assembly program which would flash one of LED’s on the RaspberryPi board on and off. Once we understood how the RaspberryPi stored the pins as memory locations this part was very straight forward. We simply cleared the pins then wrote a 1 to the required bits in the correct memory location $-$ the location which stored the setting of pins 10-19. This set the required pin (16) as an output. Next we had to write a 1 to bit 16 in the correct memory address for the RaspberryPi, we then had to clear then pins and write a 0 to this same position. This caused the LED to flash on and off too fast for us to see. To fix this we created a loop within the assembly code which would decrement 1 from 0xFF0000. This process took enough time to act as a delay so that the LED stayed on for a set period of time and then off for the same period of time.

\section{Extension}
\subsection{Overview}
For our extension, our initial idea was to create a binary clock, i.e. a representation of the twenty-four hour format through LED’s. We were going to have one row each for hours, minutes and seconds, represented by 5,6,6 LED's respectively. However, we were successful in implementing a binary clock quite quickly using the internal time of the RaspberryPi. Therefore, we decided to implement further functionality. 

The first step attempt was to find a way for the clock to keep the correct time since the RaspberryPi clock loses power when it is turned off. However, this would require an additional hardware clock which would keep the track of the real-world time. Unfortunately, we did not have time to acquire the necessary components. Therefore, we pursued alternatives in order to extend our binary clock. As a group we decided to try and turn our binary clock into an alarm clock. This required implementing three buttons which allow you to change the mode between clock, set time, and set alarm. We were able to utilise the audio port on RaspberryPi to allow us to play music when the alarm sounds. Moreover, you can also use the mode button to stop the music sounding. This enables our extension to work as a fully functional alarm clock.

\subsection{High Level Design and Discussion}
Implementing the initial binary clock was straight forward. We used 17 LED’s in total which meant that one LED was connected to each GPIO port on the RaspberryPi. Then we simply wrote a C program which would read the current system time and represent this on the LED’s by writing either HIGH or LOW to each pin. The difficultly was extending our implementation. Our first task was to find a way to drive more than 17 outputs using only the 17 pins that we had access to. This is where we needed the help of some additional hardware. We used shift registers to increase our number of outputs. The shift registers allowed us to drive a maximum of eight devices from 3 GPIO ports. This is achieved through sending data serially, which is then executed in parallel by the shift register. We used three shift registers to implement our 17 LED’s. One was used for each row so that each the hours, minutes and seconds were driven by a different shift register. The idea behind this was that if there did happen to be any discrepancy in time between the shift registers, then it wouldn’t be noticeable since all of the LED’s in each row would change at the same time, thanks to the parallel output. \par

After much frustration over the hardware we were able to set up our LED’s and shift registers correctly, which now meant we were able to control all 17 LED’s from 9 pins, freeing the other 8. Thankfully, our implementation of the clock code was incredibly easy to adjust for the method of transferring information. Our code relied on taking the current time and then, without loss of generality, taking the minutes and extracting its binary representation. Each bit was then sent as a signal to the appropriate LED. Therefore, we only had to change how the data was sent. Instead of sending the signal to a specific pin for each LED, we simply sent the bits in serial to the shift register. \par

Once we had our LED array working with our shift registers, we were able to extend our clock further to incorporate more features. The first feature we added was the ability to change the time. This was desrieable since we were currently driving the clock off of the RaspberryPi time which was not correct since it didn't have constant power. With the addition of three buttons we were now able to change the mode the clock was in, set the hours and minutes through the use of the two other buttons, and then return to the normal clock mode upon pushing the third button again. \par

The buttons were fairly straightforward to implement. The only issue came from how often we were reading from the buttons. Initially, we had a delay of 1 millisecond so that the program would not miss a user pressing the button. However, this led to a slight issue when we attempted to count how many times the user had pressed the button. Due to the tiny interval of 1 millisecond, the program read the length of time the button was pressed as the amount to increment the counter. Obviously, this was not desirable. To fix this, we added a delay of 300 milliseconds between each read of the pin. After physical testing this seemed an appropriate amount of time. This also meant that if you held the button down then the time would increment relatively quickly.\par

The final challenge of our extension was to get the RaspberryPi to output sound when the alarm time was reached, without pausing our clock program. Setting the alarm time was the same process as setting the time. We simply added an additional mode which allowed you to set the time for an alarm and then within the code we tested if the current time was equal to this set alarm time. Our first few attempts using additional libraries were unsuccessful and caused the RaspberryPi to crash on multiple occasions. We then attempted to use system commands to play the audio file directly, but this caused our program to be pause whilst the music was played. Obviously this was undesirable for a clock. Our solution was to create a background process using a Linux command that was sent to the system function in order to be executed. This way, the clock would not stop when the alarm turned on. Another challenge was figuring out how to turn off the alarm by pressing the mode button. Using the same function, we passed a Linux command that kills all the processes involving the music player.

\subsection{Testing}
Most of our testing was done by hand because of the physical nature of our extension. Initially testing involved checking that the appropriate LED’s were lighting in the right order and at the right times. Once we added our button implementation we had to test the buttons worked accordingly, and as discussed above we did have a few issues with the program reading the input from the buttons too frequently. This was only discovered through physical testing, otherwise it would have gone unnoticed. Finally, testing our alarm feature required rather extensive testing as we had to test multiple scenarios for when the alarm was set. In order to test this we commented parts of our code and initialised the clock time and alarm time one minute apart. We then observed to our clock to check that the alarm sounded on the minute change. We then had to consider edge cases, such as when the hour changed to make sure that there were no issues. Again we set the alarm time and clock time appropriately by hard coding it into our implementation and observed the result to make sure the alarm clock was behaving as expected. 

\section{Group Reflections}
Our main strength as a team was our communication. We were always talking to each other about our specific parts through social media. I think the structure of our work also assisted with our group work. For each major task, i.e. when beginning one of the four parts of the project, we would sit down as a group and work through the first part of the task. For example with the emulator we worked on the initial code to decide how were going to split a binary instruction. By sitting down as a team and deciding on how our implementation would work, everyone understood the general overview of how we were designing our software. This overall understanding meant that each person knew how their part fitted into the overall program. Consequently, when we merged all of our code together we found that the main bulk of our implementation worked, and it was just a case of trying to work out some of the edge cases which we had missed. \par

The one downfall of this approach was when the same functionality was needed in different parts of the project. Since we had worked independently on our parts we did have a few conflicts on some of the edge cases when merging our code.This was most prevalent in the assembler between the branch and single data transfer instructions because they both relied on the address of the instructions to either branch, or store memory address to data which would be written at the end of the program. We also discovered that there was some shared functionality between single data transfer and data processing. This led to some repeated code which could have been avoided if we had worked together more closely on these two parts. \par

Overall, we believe that our time management was our key strength as we were able to hit our deadlines and finish the main bulk of the project in good time. On the other hand we believe our main weakness was our use of git. As highlighted in our checkpoint we hadn’t utilised the branching functionality of git which did cause a few merge issues throughout the development of our project. Sadly, by the time we had our checkpoint we had completed both the emulator and assembler which were the key parts when branching would have been most useful. When it came to part 3 and 4 of the project, a lot more time was spent working together in labs since we were working directly with the RaspberryPi.

\section{Individual Reflections}
\subsection{Oana:}
From my point of view, working in a group is both more powerful and more challenging than working alone. The ARM11 project gave me the opportunity to understand how to communicate effectively in a team and how important is to do your part on time. Additionally, I learned to respect other people’s opinions and to dedicate my time towards working together to fulfil our aspirations. My main focus was on the single data transfer instructions. Whenever I encountered difficulties, the team was there to help me. Time management was one of my key strengths because I always feel responsible for finishing my part on time and having everything done before the deadline. I appreciate that my team shared my expectations so every time a deadline was approaching our work was prepared beforehand. Thinking about my weaknesses, I consider myself not so confident about the hardware part of the project because I do not have a strong understanding about the theory that is hidden behind the circuitry. Overall, I enjoyed working in such a great team and I admire the passion that each of us put in to finish this project. 

\subsection{Andrew:}
I found working in a group required a lot of discipline. Moreover, being the group leader added more stress due to the additional responsibility of deciding meeting times, deadlines and trying to make sure that the entire project was on schedule. However, I think that strong communication between all of the members allowed us to work together very well. My main strength, which I didn’t expect, was on the hardware side. It may have been due to the fact that I was the one who physically kept the RaspberryPi which meant that I spent some of my own time wiring up the breadboards. This meant that whenever we had to change any of the hardware I would be the one to rewire the breadboard, since I was the one who had wired it in the first place. Perhaps the main thing I would do differently with my next group project would be to utilise the functionality of git more. A noticeable amount of time was spent fixing merge issues with git, which I feel could have been avoided if I had a better understanding of git. I found that our group worked together very well when debugging. Since a lot of our bugs were caused by conflicts between different people’s code, we all needed to work together to identify the cause of these conflicts.

\subsection{Marta:}
I truly enjoyed working in a group and I have been very excited about this project since we received the specification.  The four of us worked together for the Topics project as well so we knew from the beginning that we would get along well. However, coding in a team was much more demanding than we thought but I believe that we managed to coordinate ourselves very well and I can say that everything went smoothly. I was in charge of the multiply instructions for both emulator and assembler. I think that my key strength was coding because I always managed to finish my part significantly before the deadline and I could also manage the input and output parts as well as some miscellaneous functions for the assembler. I also worked alongside Maurizio in implementing the pipeline for the emulator. Synchronising our work was easy due to the fact that we worked together so much, meeting everyday in the labs. My coding skills proved to be very useful in implementing the extension, where they compensated for my greatest weakness, which was hardware. For me, the extension represented the most interesting part of our project.  My team mates came with very interesting solutions and I believe that together we did our best to create a product as fine as the time and our skills allowed. I had fun working alongside my colleagues again and look forward to working with them in the future.

\subsection{Maurizio:}
I have really looked forward to the opportunity of working in groups and I must say that not only was it a pleasant experience, but it also honed my teamwork and programming skills. We were able to split the tasks and assign each of us several bits for the project. However, we still helped each other whenever the situation asked for it, for example, helping team members in the process of debugging. I was in charge of the branch instruction in both the assembler and emulator. I found the most difficult part was trying to synchronise the effect of the instructions with the Program Counter. Another subtlety I faced was preserving the correct offset and taking into account the two's complement format. My contribution for the project is also noteworthy in collaborating with Marta in order to get the pipeline right. Moreover, I assisted Andrew with the binary clock extension in the process of getting a better understanding of the hardware side of our project. As far as my strengths are concerned, I consider that working diligently on my parts and meeting deadlines would be the main assets. Furthermore, I reckon that the flexibility in terms of both time management and providing help for my teammates throughout the project served as a great instrument for our team successfully completing the assignment. I believe that coping with the hardware part constituted my greatest weakness, but as a group we wanted to broaden our hardware related knowledge due to the fact that the JMC course is significantly software oriented.
\end{document}
